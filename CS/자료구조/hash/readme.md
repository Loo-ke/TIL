# 해시
키 밸류의 형태인 자료구조

전화번호부랑 똑같다
이름이 키, 전화번호가 밸류

모든 데이터 타입으로 접근이 가능하다


get / put / getOrDefault

string을 기반으로 정보를 기록할 때는 거의 무조건 해시

## 해시 테이블
- key 와 value를 가진다.
- 해시 함수를 이용해서 키 값에 인덱스를 배정, 인덱스의 값에 데이터를 넣는 자료구조


```
이름 : 이종욱
나이 : 20
전화번호 : 010-1234-1234
이메일 : luke@devd.co.kr
```
## 해시
배열은 키값으로 숫자만 받을 수 있다.
해시는 키값을 문자열로 받을 수 있다.
- 키와 값이 한 쌍으로 구성된 데이터

단방향 암호화 기법으로 해시 함수를 이용하여 고정된 길이의 암호화된 문자열로 바꿔버리는 것을 의미

문자열로 받은 키 값을 해싱이라는 과정을 통해 일정 길이의 주소값으로 바꿔서 저장해두고 있기 때문이다.

### 해시 함수
- 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수





## JS에서 해시


```
const hashArr = [];
hashArr['나이'] = 20;
hashArr['직압'] = '학생';

console.log(hashArr['나이']) // 20
console.log(hashArr) // ['나이' : 20, '직업' : '학생']
```
오오... 희소배열이라는 친구 덕분에 이런 모양이 가능하다!


## 해시 함수를 직접 만들면?
- key를 갖고 value를 찾으려고 하면, key를 배열의 유효한 인덱스로 변환하는 방법이 필요하다. = 해시 함수(Hash Function)
- key를 해시 함수에 입력하면, key들은 각각 항상 같은 인덱스들로 변환돼야 한다.
- 하지만 반대로 변환은 불가능 -> 단방향 함수

인덱스로 변환하는 과정 중에 인덱스가 겹치면 ?! -> 충돌!!!

#### ex)
예를 들어 글자 수로 인덱스를 정하는 해시 함수가 있다!

```
const arr = [
  'pizza' : '10won',
  'cake' : '20won',
  'taco' : '30won'
]
```
해시 테이블에서 
p,i,z,z,a = 5글자

|index|value|
|-----|-----|
|1|-|
|2|-|
|3|-|
|4|-|
|5|'10won'|

4글자는 겹친다 = 충돌
|index|value|
|-----|-----|
|1|-|
|2|-|
|3|-|
|4(cake, taco)|??|
|5|'10won'|

#### 이럴 경우엔 충돌처리
1. 개별 체이닝
- 같은 장소에 여러 데이터를 저장하는 중첩 데이터 구조를 사용
- 충돌하는 데이터를 같은 인덱스에 중첩해서 저장
- 테이블의 길이보다 더 많은 데이터를 저장할 수 있다.


|index|value|
|-----|-----|
|1|-|
|2|-|
|3|-|
|4|['cake' , '20won'], ['taco','30won']|
|5|'10won'|

2. 선형 탐색법
- 각 위치에 하나의 데이터만 저장한다는 규칙
- 충돌이 발생하면 다음 빈 인덱스를 찾고 빈 인덱스 공간에 저장
- 주변이 모두 채워져 있는 문제에 취약함


|index|value|
|-----|-----|
|1|-|
|2|-|
|3|-|
|4|['cake' , '20won']|
|5|'10won'|
|6|['taco' , '30won']|

3. 제곱 탐사법
- 탐사하는 폭이 고정폭이 아닌 제곱으로 늘어난 부분에 선형 탐사법과 차이점을 가진다.


## 조금 더 쉽게 할 수 있다! MAP

- new Map()
  - Map 객체 생성
- map.set(key,value)
  - key를 이용해 value값을 저장
- map.get(key)
  - key에 해당하는 value를 반환
- map.has(key)
  - key가 존재한다면 true, 없다면 false를 반환
- map.size
  - 요소의 개수를 반환

